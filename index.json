[{"categories":[],"content":"Paxos的理解困境 曾经有个很牛逼的大佬说，这个世界上只有一种一致性算法，那就是Paxos，其它的算法都是残次 品。 基于Paxos的算法变种有ZAB、Raft。 ","date":"2021-09-14","objectID":"/paxos-algo/:1:0","tags":[],"title":"Paxos算法学习","uri":"/paxos-algo/"},{"categories":[],"content":"Paxos究竟在解决什么问题？ Paxos用来确定一个不可变变量的取值 取值可以是任意的二进制数据。 一旦确定将不再更改，并且可以被获取到（不可变性、可读取性）。 系统有多个存储的节点，这些节点之间的数据要保持一致。 系统有多个写入的节点，这些写入的节点会存在并发，如何确定由哪个节点写入？ 多个写入节点可能会出现故障. 多个存储节点也可能出现故障，但是要保证半数以上的存储节点是可用并且值是一致 的。 写入的节点称为proposer，决定写入数据的节点称为acceptor。 ","date":"2021-09-14","objectID":"/paxos-algo/:1:1","tags":[],"title":"Paxos算法学习","uri":"/paxos-algo/"},{"categories":[],"content":"Paxos如何在分布式存储系统中应用？ 数据本身可变，采用多副本的方式进行存储 多个副本的更新操作序列[Op1,Op2,Op3,…,Opn]是相同的、不变的。 用Paxos依次来确定不可变变量Opi的取值（即第i个操作是什么）。 每确定完Opi之后，让各个数据副本执行Opi，依次类推。 Google的Chubby [‘tʃʌbi] 等都采用了Paxos来对数据副本的更新序列达成一致。 ","date":"2021-09-14","objectID":"/paxos-algo/:1:2","tags":[],"title":"Paxos算法学习","uri":"/paxos-algo/"},{"categories":[],"content":"Paxos算法的核心思想是什么？ 设计一个系统，来存储名称为var的变量 系统内部由多个Acceptor组成，负责存储和管理var变量。 外部有多个proposer机器任意并发调用API，向系统提交不同的var取值。 var的取值可以是任意的二进制数据 系统对外的API库接口为： propose(var,V)=\u003e\u003cok,f\u003eor\u003cerror\u003e ，proposer机器向系统发出请求，希望把var设置成V，系统会返回ok和系统内部已经确定下来的取值，或者返回error，如果说系统内部将这个值设置成V，那么f就是V，否则f就是其他proposer设置成的结果。 这个时候我们对于这个系统的初步印象可以是这样的，不一定是对的。 PaxosPaxos \" Paxos 系统需要保证var的取值满足一致性 那么就会要求 如果var的取值还没确定，则var的取值为null。 一旦var的取值被确定，则不可被更改，并且可以一直取到这个值。 系统需要满足容错特性 可以容忍任意proposer机器出现故障。 可以容忍少数Acceptor故障（少于半数）。 为了讲解简单，暂不考虑 网络分化。 Acceptor故障会丢失var的信息。 确定一个不可变变量——难点 管理多个Proposer的并发执行 保证var变量的不可变性 容忍任意Propose机器故障 容忍半数以下Acceptor机器故障 确定一个不可变变量的取值——方案1 先考虑系统由单个Acceptor组成。通过类似互斥锁机制，来管理并发的proposer运行。 Proposer首先向acceptor申请acceptor的互斥访问权，然后才能请求acceptor接受自己的取值。 acceptor给proposer发放互斥访问权，谁申请到互斥访问权，就接收谁提交的取值。 这样的话，就可以让proposer按照获取互斥访问权的顺序依次访问acceptor。 一旦acceptor接收了某个proposer的取值，则认为var的取值被确定，其他proposer不再更改。 方案1——基于互斥访问权的acceptor的实现 acceptor保存变量var和一个互斥锁lock acceptor::prepare(): 加互斥锁，给予var的互斥访问权，并且返回var当前的取值f。 acceptor::release(): 解互斥锁，收回var的互斥访问权。 acceptor::accept(var,V): 如果已经加锁，并且var没有确定值，则设置var为V。并且释放锁。 方案1——propose(var,V)的两阶段实现 第一阶段：通过acceptor::prepare获取互斥访问权和当前var的取值。 如果不能，返回error，代表锁已经被别人占用了。 第二阶段：根据当前var的取值f，执行选择。 如果f为null，则通过acceptor::accept(var,V)来提交数据V。 如果f不为空，则通过acceptor::release()释放访问权，返回\u003cok,f\u003e。这代表当前proposer想要修改历史的var的取值，根据一致性原则，之前确定下来的值不改，返回已经确定的取值。 方案1——总结 通过acceptor互斥访问权让proposer序列运行，可以简单的实现var取值的一致性。 proposer在释放互斥访问权之前发生故障，会导致系统陷入死锁。 不能容忍任意的Proposer机器故障。 方案2——引入抢占式访问权 方案1我们看起来就是因为死锁的问题导致不够完善，那么我们怎么解决死锁问题呢？ acceptor可以让某个proposer获取到的访问权失效，不再接收它的访问。 之后，可以将访问权发放给其他proposer，让其他proposer访问acceptor。 那么对于acceptor来说，它就只需要记录下最新发放的访问权就行了。新的有用，旧的不行。可是要怎么判断新旧呢？ Proposer向acceptor申请访问权时指定编号epoch /ˈiː.pɒk/ （越大的epoch越新），获取到访问权之后，才能向acceptor提交取值。 acceptor采用喜新厌旧的原则。 一旦收到更大的新epoch的申请，马上让旧epoch的访问权失效，不再接收他们提交的取值。 然后给新epoch发放访问权，只接收新epoch提交的取值。 新epoch可以抢占旧epoch，让旧epoch的访问权失效。旧epoch的proposer将无法运行，新epoch的proposer将开始运行。 为了保持一致性，不同的proposer之间采用“后者认同前者”的原则。 在肯定旧epoch无法生成确定性取值时，新的epoch才会提交自己的value。 一旦旧epoch形成确定性取值，新的epoch肯定可以获取到此取值，并且会认同此取值，不会破坏。 方案2——基于抢占式访问权的acceptor的实现 acceptor保存的状态 当前var的取值\u003caccepted_epoch,accepted_value\u003e 最新发放访问权的epoch(lastest_prepared_epoch) acceptor::prepare(epoch): 只接收比lastest_prepared_epoch更大的epoch，并且给予访问权， 记录lastest_prepared_epoch=epoch；然后返回当前var的取值 acceptor::accept(var,prepared_epoch,V): 验证是否prepared_epoch==lastest_prepared_epoch 假如验证通过，设置var的取值\u003caccepted_epoch,accepted_value\u003e= \u003cprepared_epoch,V\u003e 假如不通过，说明已经有了更大的epoch申请到了访问权，当前proposer获 取到的访问权失效。 方案2——propose(var,V)的两阶段实现 第一阶段：通过acceptor::prepare获取互斥访问权和当前var的取值。 我们可以简单地以当前时间戳为epoch，通过acceptor::prepare(epoch)，获取epoch轮次的访问权和当前var的取值。 如果不能获取，返回error。说明当前已经有个相同或者更大的epoch获取到了访问 权。 第二阶段：采用“后者认同前者”的原则执行。 在肯定旧epoch无法生成确定性取值时，新的epoch才会提交自己的value。 一旦旧epoch形成确定性取值，新的epoch肯定可以获取到此取值，并且会认同此取值，不会破坏。 如果var的取值为空，则肯定旧epoch无法生成确定性取值，则通过 acceptor::accept(var,prepared_epoch,V)提交数据V。成功后返回\u003cok,V\u003e 如果accept失败，返回error。（被新的epoch抢占或者acceptor故障） 如果var的取值存在，则此取值肯定是确定性取值，此时认同它不再更改，直接返回\u003cok,accepted_value\u003e。 画图来说明下，Proposer1向acceptor发送访问权申请 Proposer2向acceptor发送访问权申请 Proposer2拿到了访问权，向acceptor提交自己的数据。且之后Proposer1向acceptor提交自己的 数据。 再之后proposer3向acceptor发送访问权申请。 因为这个时候已经有确定性取值了，proposer3会认可这个值，不再进行修改。 方案2——总结 基于抢占式访问权的核心思想 让Proposer将按照epoch递增的顺序抢占式的依次运行，后者会认同前者。 可以避免proposer机器故障带来的死锁问题，并且仍可以保证var取值的一致性。 仍需要引入多acceptor 单机模块acceptor故障将会导致整系统宕机，无法提供服务。 思考——关于方案1和2 方案1 如何控制proposer的并发运行？ 为何可以保证一致性？ 为什么会有死锁问题？ 方案2 如何解决方案1的死锁问题？ 在什么情况下，proposer可以将var的取值确定为自己提交的取值？ 如何保证新epoch不会破坏已经达成的确定性取值？ ","date":"2021-09-14","objectID":"/paxos-algo/:1:3","tags":[],"title":"Paxos算法学习","uri":"/paxos-algo/"},{"categories":[],"content":"Paxos Paxos在方案2的基础上引入多acceptor。 acceptor的实现保持不变，仍然采用“喜新厌旧”的原则运行。 Paxos采用了少数acceptor服从多数的思路（少数服从多数）。 在方案2中，一旦某个epoch的取值f被系统里仅有的acceptor接受，那么我们就认为var的取值被确定了。那么在Paxos中，我们定义，一旦某epoch的取值f被半数以上acceptor接受，则认为此取值被确定为f，不再更改。 Acceptor的实现不变 Propose的两阶段实现 propose(var,V)第一阶段：选定epoch，获取epoch访问权和对应var的取值。 获取半数以上acceptor的访问权和对应的一组var取值。 因为半数以上和半数以上必然存在交集，那么就可以保证，一个epoch最多只会有一个proposer拿到访问权，进入第二阶段运行。 propose(var,V)第二阶段：采用后者认同前者的原则执行。 在肯定旧epoch无法生成确定性取值时，新的epoch才会提交自己的value。 一旦旧epoch形成确定性取值，新的epoch肯定可以获取到此取值，并且会认同此取值， 不会破坏。 如果proposer在第一阶段获取到的var取值都为空，则旧epoch无法形成确定性取值。此时努力使\u003cepoch,V\u003e成为确定性取值。 向所有的epoch对应的所有acceptor提交取值\u003cepoch,V\u003e。 如果收到半数以上成功，则返回\u003cok,V\u003e。 否则，则返回error（被新的epoch抢占或者accepor故障）。 如果说var的取值存在，那么就要认同最大accepted_epoch对应的取值f，努力使\u003cepoch,f\u003e成为确定性取值。 如果f已经出现了半数以上，则说明f已经是确定性取值，直接返回\u003cok,f\u003e 如果说f只是出现了半数以下，那此时f可能是确定性取值，也可能不是，不管怎样，此时的epoch都会认同这个f，向所有的acceptor提交这个取值\u003cepoch,f\u003e ​ 我们想象一下，当proposer1提交的\u003cepoch1,f\u003e被acceptor接受，epoch1形成了确定性取值，紧接着下一个就是proposer2的提交的epoch2，proposer2肯定是可以获取到至少一个确定性取值\u003cepoch1,f\u003e，并且在epoch2获取到的所有取值里面，epoch1是一个最大的epoch，所以epoch2会认可epoch1提交的取值f，以此类推，后面的epoch也都会认可epoch1提交的取值f，不会进行更改。 ​ 画图讲解下第一阶段 ​ proposer1向所有的acceptor发出prepare请求，并且返回var的当前取值，全部为空。 ​ proposer1发现所有的取值为空，这个时候proposer1就可以选定自己的取值V1为确定性取值向所有的acceptor发送accept请求。proposer1进入第二阶段，向第一个acceptor发出请求。 ​ 在这个时候，P2进入第一阶段，向acceptor发出prepare请求。使用epoch2企图抢占访问权。P2向前两个acceptor发出了prepare请求。 ​ epoch1的访问权直接失效，epoch2获取到了访问权，acceptor向P2返回了节点当前保存的结果。P2进入了第二阶段，在P2发起accept请求之前，P1继续向另外的两个节点发送accept请求。 ​ 在这个情况中，第二个acceptor会拒绝P1的请求，因为epoch1访问权失效，第三个acceptor接受了V1这个取值并且返回成功。这个时候，epoch1已经形成了确定性取值V1，也是P1的取值V1。 ​ 这个时候，P2开始在第二阶段向acceptor发起accept请求。它选定取值里面最大的epoch的取值，也就是epoch1提交的V1，然后开始让acceptor接受V1。 ​ 所以在这种情况下，我们可以看到P2也形成了确定性取值V1，因为它是直接选择epoch1提交的取值V1，所以即使epoch1和epoch2都形成了确定性取值，这两个取值不会发生冲突。 ​ 我们可以假设，P1的后两个accept请求没有成功发出去，那么epoch1无法形成确定性取值，epoch2也会照样选择V1来形成确定性取值，也不会形成冲突。 Paxos——总结 Paxos算法的核心思想 在抢占式访问权的基础上引入多个acceptor 保证一个epoch，只有proposer运行，proposer按照epoch递增的顺序依次运行。 新epoch的proposer采用“后者认同前者”的思路运行。 在肯定旧epoch无法生成确定性取值时，新的epoch才会提交自己的value。 一旦旧epoch形成确定性取值，新的epoch肯定可以获取到此取值，并且会认同此取 值，不会破坏。 Paxos算法可以满足容错性要求 半数以下acceptor出现故障时，存活的acceptor仍然了可以生成var的确定性取值。 一旦var取值被确定，即使出现了半数以下acceptor故障，该取值也可以被获取，并且不再更改。 Paxos算法的livelock问题 新轮次的抢占会让旧轮次停止运行，如果每一轮次在第二阶段成功之前都被新一轮次抢占，则 导致活锁，怎么解决呢？ ","date":"2021-09-14","objectID":"/paxos-algo/:1:4","tags":[],"title":"Paxos算法学习","uri":"/paxos-algo/"},{"categories":[],"content":"思考题 在什么情况可以认为var的取值被确定，不再更改？ Paxos的两个阶段分别在做什么？ 一个epoch是否会有多个proposer进入第二阶段？ 在什么情况下，proposer可以将var的取值确定为自己提交的取值呢？ 在第二阶段，如果获取的var取值都为空，为什么可以保证旧epoch无法形成确定性取值？ 新epoch抢占成功之后，旧epoch的proposer将如何运行？ 如何保证新的epoch不会破坏已经达成的确定性取值？ 为什么在第二阶段存在var取值时，只需要考虑accepted_epoch最大的取值f？ 在形成确定性取值之后，出现了任意半数以下acceptor故障，为何确定性取值不会被更改？ 如果proposer在运行过程中，任意半数以下的acceptor出现故障，此时将如何运行？ 正在运行的proposer和任意半数以下acceptor都出现故障时，var的取值可能是什么情况？为 何之后新的proposer可以形成确定性取值？ ","date":"2021-09-14","objectID":"/paxos-algo/:1:5","tags":[],"title":"Paxos算法学习","uri":"/paxos-algo/"},{"categories":[],"content":"参考资料 分布式系列文章——Paxos算法原理与推导 ","date":"2021-09-14","objectID":"/paxos-algo/:1:6","tags":[],"title":"Paxos算法学习","uri":"/paxos-algo/"},{"categories":[],"content":"最近新入手了一部IPad Air 4，想着为了不让其成为爱奇艺播放器，发挥生产力功效，于是搜罗资料，查找能否在iPad上实现写代码的方案。最终找到两种方法： 利用SSH连接软件，在远程服务器上利用Vim、NEOVim等编辑器软件进行编码。 首先找到的是一款名为termius的软件，下载免费，使用需内购，可是我在下载下来之后进入软件始终都无法创建账号，也就无法进行内购使用了，放弃。网上看使用过的大佬说，并不推荐这种方式，因为编码的效率太低，而且有时切出软件一小段时间后，SSH连接会断开，体验非常差。 利用code-server部署一个网页版的VScode，即“云IDE”，这样工作区在不同的设备上都能同步，而且切出后不会掉线。将网页作为WebApp添加到主屏幕上后的体验也接近于原生App(前提是服务器的带宽不能太低)。 ","date":"2021-09-10","objectID":"/code-server/:0:0","tags":[],"title":"云IDE：code-server安装使用","uri":"/code-server/"},{"categories":[],"content":"环境准备 云服务器，规格 2C4G： $ cat /etc/redhat-release CentOS Linux release 7.6.1810 (Core) ","date":"2021-09-10","objectID":"/code-server/:0:1","tags":[],"title":"云IDE：code-server安装使用","uri":"/code-server/"},{"categories":[],"content":"下载资源 下载code-server在github上的安装包： $ wget https://github.com/cdr/code-server/releases/download/v3.11.0/code-server-3.11.0-linux-amd64.tar.gz # 解压安装包 $ tar -zxf code-server-3.11.0-linux-amd64.tar.gz \u0026\u0026 cd code-server-3.11.0-linux-amd64 # ","date":"2021-09-10","objectID":"/code-server/:0:2","tags":[],"title":"云IDE：code-server安装使用","uri":"/code-server/"},{"categories":[],"content":"启动 设置登录web服务的密码，code-server要求以环境变量$PASSWORD为登录密码： $ export PASSWORD=\"123456\" 运行code-server $ ./code-server --port 8080 --host 0.0.0.0 --auth password 8080是端口,可以自己修改,注意不要与其他应用冲突。0.0.0.0是代表可以被所有ip访问. $ ./code-server --port 8080 --host 0.0.0.0 --auth password ***** Please use the script in bin/code-server instead! ***** This script will soon be removed! ***** See the release notes at https://github.com/cdr/code-server/releases/tag/v3.4.0 [2021-09-10T07:39:08.191Z] info code-server 3.11.0 4e8cd09ef0412dfc7b148b7639a692e20e4fd6dd [2021-09-10T07:39:08.192Z] info Using user-data-dir ~/.local/share/code-server [2021-09-10T07:39:08.206Z] info Using config file ~/.config/code-server/config.yaml [2021-09-10T07:39:08.206Z] info HTTP server listening on http://0.0.0.0:8080 [2021-09-10T07:39:08.206Z] info - Authentication is enabled [2021-09-10T07:39:08.206Z] info - Using password from ~/.config/code-server/config.yaml [2021-09-10T07:39:08.206Z] info - Not serving HTTPS 如图所示就是已经完成配置了。 ","date":"2021-09-10","objectID":"/code-server/:0:3","tags":[],"title":"云IDE：code-server安装使用","uri":"/code-server/"},{"categories":[],"content":"访问 在浏览器中输入服务器ip+端口号：127.0.0.1:8080，出现登录页面，输入刚才所设置的密码123456登录，即可进入Web IDE ,愉快的进行coding吧~ ","date":"2021-09-10","objectID":"/code-server/:0:4","tags":[],"title":"云IDE：code-server安装使用","uri":"/code-server/"},{"categories":[],"content":"添加插件 添加插件的步骤和vscode一致,不再累赘, 可以自己去用用实际的vscode. ","date":"2021-09-10","objectID":"/code-server/:0:5","tags":[],"title":"云IDE：code-server安装使用","uri":"/code-server/"},{"categories":["随笔"],"content":" 《娱乐至死》是美国批评家尼尔·波兹曼在1985年写成出版的，这本书主要阐述了在二十世纪后半叶美国文化中的重大变化也就是电视业的蓬勃发展和传统印刷业的没落所带来的诸多问题的批判和思考。 在传统印刷业，也就是所谓的“阐释时代”，信息的组织是具有逻辑和语境的，人们从中获得了思考和智慧。而随着电视的普及，进入电视时代的人们更愿意接受娱乐化的信息，而渐渐排斥原本具有严肃性的东西。一开始，很多严肃的新闻或者具有教育意义的节目，也都是通过电视来呈现给大众的，但久而久之，由于各种各样的原因，这些原本具有严肃性的东西等也都纷纷向娱乐靠拢。 似乎一切的内容都以娱乐的形式呈现，大量的信息充斥在人们的生活中，信息变得碎片化。虽然看似我们从电视中获取了很多新闻资讯、很多知识，但是这些信息是没有语境和逻辑的，我们并没有主动去思考或者说已经没有机会去思考这里面的真假，很多观点都是别人整理好后塞给我们的。 我们通过电视媒体，给自己制造了获取很多知识的假象，我们已经很少去真正思考信息的来源以及信息的真假，只是被动地接受，最后，看似收获了很多知识，实则一无所获。 进入互联网时代也是一样，我们心甘情愿的沦为娱乐的附庸，无脑的享受着各种各样的新闻、娱乐资讯，刷微博，刷抖音，刷b站，越来越偏向于不动大脑的开怀大笑，最后成为一个娱乐至死的物种。 读完这本书，我才后知后觉，过去做过的很多事情，譬如看了很多电影、书、纪录片，实际上我真正深入思考的有多少？就算是我爱看的历史纪录片，事实上更多时候我也是听听故事，并没有多少时刻去认真思考整个历史事件的起因、经过和结局对于历史的推进作用。 当然，如果生活中只存在严肃性的东西，禁止一切娱乐，那也太矫枉过正了，显得生活太枯燥。我们不应该禁止娱乐，更正确的方式，我想应该是减少娱乐的时间，只在碎片化的时间段内浏览一些娱乐资讯，更多大块的时间用来读书和思考，真正提高个人整体素质和境界。 ","date":"2021-06-17","objectID":"/amusing-to-death/:0:0","tags":[],"title":"娱乐至死","uri":"/amusing-to-death/"},{"categories":[],"content":"添加评论系统 启用评论系统utterances 在hugo的配置文件（config.toml）中启用utterances，打开config.toml，添加如下： # Utterances comment 评论系统设置 (https://utteranc.es/) [params.page.comment.utterances] enable = true # owner/repo repo = \"YourUsername/YourUsername.github.io\" ##自己的github仓库地址 issueTerm = \"pathname\" label = \"\" lightTheme = \"github-light\" darkTheme = \"github-dark\" repo的格式为：github用户名/创建的仓库名 github上安装 utterances 首先必须在 github 上进行安装 utterances，访问 utterances应用程序 然后点击 Install 按钮进行安装。 在这里可以选择可以关联的存储库，可以选择我们所拥有的库(也包括未来建立的库)或者某一个仓库，这里只选择某一个需要进行评论的库，这样比较好。 安装完成即可，随后访问 utterances应用程序 就不再是安装而是是执行配置项目。 此时服务端配置已经完成，接着访问博客测试下评论。 ","date":"2021-06-04","objectID":"/theme-seo/:0:1","tags":[],"title":"主题优化-添加评论系统和内置搜索","uri":"/theme-seo/"},{"categories":[],"content":"内置搜索系统 原理：在执行push操作触发Actions编译站点代码到./public目录后，再执行生成索引文件操作，生成index.json到./public目录，并自动上传文章索引至algolia上，以实现站内搜索功能。 algolia实现内置搜索 前往官方网站https://www.algolia.com/ 使用 GitHub 或 Google 帐号登录。登录完成后根据提示信息填写一些基本的信息即可，注册完成后前往 Dashboard，我们可以发现 Algolia 会默认给我们生成一个 app。 选择 Indices，添加一个新的索引，index-name索引名自定义填写，并记录下来，后面网站配置要用到。再选择API keys，记录“Search-Only API Key”、“Admin API Key”两个秘钥。 由于我这里使用的主题是LoveIt，主题配置文件config.toml内置支持algolia插件，所以只需要在站点目录下的config.toml中，配置刚刚生成的索引和Search-Only API Key即可： [root@web-blog web]# vim config.toml [languages.zh-cn.params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"algolia\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [languages.zh-cn.params.search.algolia] index = \"yuepu-blog\" #索引名称 appID = \"SSC09FNCJM\" #应用ID searchKey = \"b42948e51daaa93df92381c8e2ac0f93\" #Search-Only API Key 利用GitHub Action配置自动上传索引文件 编辑GitHub Action的CI/CD 配置文件gh-pages.yml，安装algoliasearch，并且使用Node.js配置秘钥文件： [root@web-blog web]# vim .github/workflows/gh-pages.yml ... - name: Use Node.js uses: actions/setup-node@v1 with: node-version: '15.x' - name: Push Argolia Index run: | npm install algoliasearch #安装algoliasearch插件 node push_argolia_index.js #使用我们配置的js文件 env: ALGOLIA_ADMIN_KEY: ${{ secrets.ALGOLIA_ADMIN_KEY }} 然后在站点根目录新建push_argolia_index.js文件，内容如下： /* 上传 algolia 索引文件 参考：https://www.algolia.com/doc/guides/getting-started/quick-start/tutorials/quick-start-with-the-api-client/javascript/?client=javascript */ // For the default version const algoliasearch = require('algoliasearch'); const appID = \"747LJ10EI7\" const indexName = \"ryan-space\" const adminKey = process.env.ALGOLIA_ADMIN_KEY const indexFile = \"./public/index.json\" const client = algoliasearch(appID, adminKey); const index = client.initIndex(indexName); const indexJson = require(indexFile); index.saveObjects(indexJson, { autoGenerateObjectIDIfNotExist: true }).then(({ objectIDs }) =\u003e { console.log(objectIDs); }); 这里我们一直没有用到的Admin API Key，需要在Setting -\u003e Secrets，新建仓库秘钥，名字取为ALGOLIA_ADMIN_KEY，以便Action 和 js中调用。 至此，配置就完成了。 ","date":"2021-06-04","objectID":"/theme-seo/:0:2","tags":[],"title":"主题优化-添加评论系统和内置搜索","uri":"/theme-seo/"},{"categories":[],"content":"参考 Hugo 博客使用 utterances 作为评论系统 algolia官网 上传 algolia 索引文件 参考：https://www.algolia.com/doc/guides/getting-started/quick-start/tutorials/quick-start-with-the-api-client/javascript/?client=javascript ","date":"2021-06-04","objectID":"/theme-seo/:0:3","tags":[],"title":"主题优化-添加评论系统和内置搜索","uri":"/theme-seo/"},{"categories":[],"content":"Google-SRE教程 ","date":"2021-06-04","objectID":"/links/:0:0","tags":[],"title":"学习资料","uri":"/links/"},{"categories":[],"content":"wiki–运维文档 此社区目的有两点： 1.共同整理出标准文档，进行持续维护，方便大家查阅使用 2.一起研究出一些东西出来，推动国内的运维技术发展 ","date":"2021-06-04","objectID":"/links/:0:1","tags":[],"title":"学习资料","uri":"/links/"},{"categories":[],"content":"K8s训练营 阳明的博客 GO example 中文版 鸟哥的Linux私房菜 ","date":"2021-06-04","objectID":"/links/:0:2","tags":[],"title":"学习资料","uri":"/links/"},{"categories":[],"content":" 感谢 @Ryan4Yin 提供了友链页面模板~ LoveIt主题菜单栏标签参考（https://zhaouncle.com） 在友链形成的网络中漫游，是一件很有意思的事情。 以前的人们通过信笺交流，而我们通过友链串联起一个「世界」。希望你我都能在这个「世界」中有所收获 注： 下方友链次序每次刷新页面随机排列。 ","date":"2021-05-31","objectID":"/friends/:0:0","tags":[],"title":"友链","uri":"/friends/"},{"categories":[],"content":"交换友链 如果你觉得我的博客有些意思，而且也有自己的独立博客，欢迎与我交换友链~ 可通过 Issues 或者评论区提交友链申请，格式如下： 站点名称：Yuepu`s Blog 站点地址: https://pingyangblog.com/ 个人形象：https://pingyangblog.com/images/avatar.jpg 站点描述：不急，但是不停~ // 以下为样例内容，按照格式可以随意修改 var myFriends = [ [\"https://chee5e.space\", \"https://chee5e.space/images/avatar.jpg\", \"@芝士部落格\", \"有思想，也有忧伤和理想，芝士就是力量\"], [\"https://blog.k8s.li/\", \"/avatar.png\", \"@木子\", \"垃圾佬、搬砖社畜、运维工程师 0) { var rndNum = Math.floor(Math.random()*myFriends.length); var friendNode = document.createElement(\"li\"); var friend_link = document.createElement(\"a\"), friend_img = document.createElement(\"img\"), friend_name = document.createElement(\"h4\"), friend_about = document.createElement(\"p\") ; friend_link.target = \"_blank\"; friend_link.href = myFriends[rndNum][0]; friend_img.src=myFriends[rndNum][1]; friend_name.innerText = myFriends[rndNum][2]; friend_about.innerText = myFriends[rndNum][3]; friend_link.appendChild(friend_img); friend_link.appendChild(friend_name); friend_link.appendChild(friend_about); friendNode.appendChild(friend_link); targetList.appendChild(friendNode); myFriends.splice(rndNum, 1); } .linkpage ul { color: rgba(255,255,255,.15) } .linkpage ul:after { content: \" \"; clear: both; display: block } .linkpage li { float: left; width: 48%; position: relative; -webkit-transition: .3s ease-out; transition: .3s ease-out; border-radius: 5px; line-height: 1.3; height: 90px; display: block } .linkpage h3 { margin: 15px -25px; padding: 0 25px; border-left: 5px solid #51aded; background-color: #f7f7f7; font-size: 25px; line-height: 40px } .linkpage li:hover { background: rgba(230,244,250,.5); cursor: pointer } .linkpage li a { padding: 0 10px 0 90px } .linkpage li a img { width: 60px; height: 60px; border-radius: 50%; position: absolute; top: 15px; left: 15px; cursor: pointer; margin: auto; border: none } .linkpage li a h4 { color: #333; font-size: 18px; margin: 0 0 7px; padding-left: 90px } .linkpage li a h4:hover { color: #51aded } .linkpage li a h4, .linkpage li a p { cursor: pointer; white-space: nowrap; text-overflow: ellipsis; overflow: hidden; line-height: 1.4; margin: 0 !important; } .linkpage li a p { font-size: 12px; color: #999; padding-left: 90px } @media(max-width: 460px) { .linkpage li { width:97% } .linkpage ul { padding-left: 5px } } ","date":"2021-05-31","objectID":"/friends/:1:0","tags":[],"title":"友链","uri":"/friends/"},{"categories":null,"content":" 关于我 （ “曾以为走不出去的日子,现在都回不去了。”——村上春树 《且听风吟》） 保持独立思考，不急，但是不停。 昵称：乐谱 游戏：游戏热爱者，参与过MMORPG游戏《莽荒纪》（C++）的游戏模块开发和运维工作，也参与过H5游戏《九州幻境城》（lua）的服务端运维。 影视：看得最多的是动漫了，科幻、悬疑类型也很喜欢。 运动：跑步、游泳、登山。 编程语言： shell：工作语言。 Python：学习中。 曾经使用过但已经荒废的语言：Java|C++。 职业：运维工程师 目前主要以提升业务稳定性和服务响应为主的业务运维工作，目标是掌握python语言，成为运维开发工程师，并学习kubernetes，熟悉云原生技术圈，思考如何更好地利用这些技术优化基础设施，使基础设施能稳定高效地支撑业务不断成长。 理论基础：计算机网络和Linux 底层知识还很欠缺，数据结构和设计模式有时间可以看看，数据库、中间件等分布式原理知识知之甚少。还有太多需要补习的理论基础知识。 关于此博客 “对我来说，博客首先是一种知识管理工具，其次才是传播工具。我的技术文章，主要用来整理我还不懂的知识。我只写那些我还没有完全掌握的东西，那些我精通的东西，往往没有动力写。炫耀从来不是我的动机，好奇才是。\" ──阮一峰 目的是想让博客成为我在互联网世界的一张名片和一个入口。其实记录在哪里都能记录，现在移动端如此普及，但我更希望能创建一个统一的入口，能够对自己的所学所感进行思考和总结，使其以规范的方式展现出来。 注意事项 博客中的内容说到底也只是我一家之言，我只能尽量去减少错漏，但不能保证内容的正确性！ 因此请带着批判的眼光看待本博客中的任何内容。 话外 互联网浩如烟海，这个小站偏安一隅，如果它有幸被你发现，而且其中文字对你还有些帮助，那可真是太棒了！感谢有你~ ","date":"2021-05-27","objectID":"/about/:0:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":[],"content":"hugo架构图hugo架构 \" hugo架构图 现在市面上的博客很多，如CSDN，博客园，简书等平台，可以直接在上面发表，用户交互做的好，写的文章百度也能搜索的到。缺点是比较不自由，会受到平台的各种限制和恶心的广告。 而自己购买域名和服务器，搭建博客的成本实在是太高了，不光是说这些购买成本，单单是花力气去自己搭这么一个网站，还要定期的维护它，对于我们大多数人来说，实在是没有这样的精力和时间。 那么就有第三种选择，直接在github page平台上托管我们的博客。这样就可以安心的来写作，又不需要定期维护，而且Hugo作为一个快速简洁的博客框架，用它来搭建博客真的非常容易。 ","date":"2021-05-27","objectID":"/setup-hugo-blog/:0:0","tags":["搭建"],"title":"Hugo+GitHub Action+Github Pages搭建个人博客","uri":"/setup-hugo-blog/"},{"categories":[],"content":"前言 Hugo 是一个基于Go语言开发的静态博客框架，号称世界上最快的构建网站工具。本文是我在网上看的其他人的博客和一些up主的视频，通过他们的分享成功搭建好了的案例，在这里我也进行一次总结，方便以后使用。 ","date":"2021-05-27","objectID":"/setup-hugo-blog/:0:1","tags":["搭建"],"title":"Hugo+GitHub Action+Github Pages搭建个人博客","uri":"/setup-hugo-blog/"},{"categories":[],"content":"目的 通过把博客文章的源代码托管到GitHub仓库，利用GitHub Actions for Hugo功能持续集成部署，利用GitHub Pages实现网站的发布和访问，生成一个自己专属的个人博客网站。 ","date":"2021-05-27","objectID":"/setup-hugo-blog/:0:2","tags":["搭建"],"title":"Hugo+GitHub Action+Github Pages搭建个人博客","uri":"/setup-hugo-blog/"},{"categories":[],"content":"流程及原理 本地新建文章，push到 Github仓库的 main分支。main分支存放博客文章的源码。 push 操作自动触发预先配置的Actions。 GitHub Action自动执行yml文件中的\"action\"，构建打包，推送至gh-pages分支。 通过 Github Pages生成的 URL 访问即可。 ","date":"2021-05-27","objectID":"/setup-hugo-blog/:0:3","tags":["搭建"],"title":"Hugo+GitHub Action+Github Pages搭建个人博客","uri":"/setup-hugo-blog/"},{"categories":[],"content":"详细步骤 安装git和关联GitHub 这里我选择的是在Linux上搭建的，所以可以直接通过yum一条命令就能实现安装Git，其他平台的安装就不赘述了，自行百度下吧。 安装git yum install -y git 创建GitHub账户和仓库 没账号的登录GitHub创建账号，有账号的直接登录账号，点击右上角的加号—\u003eNew repository，创建一个仓库，名称必须为yourname.github.io, 其中yourname是你的github名称，按照这个规则创建才有用。点击Create repository完成创建。 本地Git关联远程的GitHub账户： 回到Linux中，用以下命令配置Github账户信息，用户名（Your Name）和邮箱（you@example.com）换成你自己的： git config --global user.email \"you@example.com\"； git config --global user.name \"Your Name\" 由于本地的 Git 仓库和 GitHub 仓库之间的传输是通过SSH加密的，所以我们需要配置验证信息,使用以下命令生成 SSH Key： ssh-keygen -t rsa -C \"youremail@example.com\" 输入命令之后，直接三个回车即可，默认不需要设置密码； 找到~/.ssh 的文件夹中的 id_rsa.pub 密钥，将内容全部复制： cat ~/.ssh/id_rsa.pub 回到GitHub中-\u003eSettings-\u003eSSH and GPG keys，新建SSH Key: New SSH key，填入刚刚复制的内容，粘贴到github的输入框中，点击Add SSH key即可保存本地的秘钥到github账号。 验证是否关联成功： [root@web-blog public]# ssh -T git@github.com You've successfully authenticated, but GitHub does not provide shell access 保存账号密码，避免每次pull、push操作都需要输入账号密码： git config --global credential.helper store 安装Hugo 下载Hugo [root@web-blog ~]# wget https://github.com/gohugoio/hugo/releases/download/v0.80.0/hugo_0.80.0_Linux-64bit.tar.gz #解压后复制到bin目录 [root@web-blog ~]# tar -zxf hugo_0.80.0_Linux-64bit.tar.gz \u0026\u0026 cp hugo /use/local/bin #hugo version查看版本 [root@web-blog ~]# hugo version Hugo Static Site Generator v0.80.0-792EF0F4 linux/amd64 BuildDate: 2020-12-31T13:37:58Z 生成博客 命令：hugo new site myblog myblog为博客的目录名，可以修改为你自己想取的名字。 [root@web-blog ~]# hugo new site myblog Congratulations! Your new Hugo site is created in /root/myblog. Just a few more steps and you're ready to go: 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \"hugo new theme \u003cTHEMENAME\u003e\" command. 2. Perhaps you want to add some content. You can add single files with \"hugo new \u003cSECTIONNAME\u003e/\u003cFILENAME\u003e.\u003cFORMAT\u003e\". 3. Start the built-in live server via \"hugo server\". Visit https://gohugo.io/ for quickstart guide and full documentation. 下载主题 主题官网：https://themes.gohugo.io ，找到想要的主题，点进去，复制下载命令，我这里下载的是even主题，在myblog目录下： git clone https://github.com/olOwOlo/hugo-theme-even.git themes/even 主题被下载到站点目录myblog下的themes/even下。 启动博客 下载完成之后需要把主题even下的./exampleSite/config.toml复制到站点根目录下，这个文件中有博客首页的一些配置项，如“关于”“标签”“分类”等的开关，设置为true或者把注释解开即可在博客上看到该项了。 为了测试文章排版效果，还需要把./exampleSite/content/下的所有文件复制到站点目录的content目录下： [root@web-blog myblog]# cp themes/even/exampleSite/config.toml ./ [root@web-blog myblog]# vim config.toml baseURL = \"https://example.com\" title = \"Your title\" themesDir = \"../..\" theme = \"even\" paginate = 8 [menu] [[menu.main]] identifier = \"home\" name = \"Home\" url = \"/\" weight = 1 [[menu.main]] identifier = \"tags\" name = \"Tags\" url = \"/tags/\" weight = 2 [[menu.main]] identifier = \"about\" name = \"About\" url = \"/about/\" weight = 3 #复制测试文本到站点目录 [root@web-blog myblog]# cp themes/even/exampleSite/content/* ./content [root@web-blog myblog]# ll content total 8 -rw-r--r-- 1 root root 486 May 13 17:02 about.md drwxr-xr-x 2 root root 4096 May 13 17:02 post 启动博客，在myblog目录下键入命令： [root@web-blog myblog]# hugo server Start building sites … | ZH-CN -------------------+-------- Pages | 8 Paginator pages | 0 Non-page files | 0 Static files | 38 Processed images | 0 Aliases | 1 Sitemaps | 1 Cleaned | 0 Built in 39 ms Watching for changes in /opt/myblog/{archetypes,content,data,layouts,static,themes} Watching for config changes in /opt/myblog/config.toml Environment: \"development\" Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop 打开浏览器访问http://localhost:1313/，预览博客网页效果。按Ctrl+C可以停止服务。 写一篇文章 [root@web-blog myblog]# hugo new post/index.md /opt/myblog/content/post/index.md created 生成的 Markdown 文件在myblog/context/post目录下： [root@web-blog myblog]# vim /opt/myblog/content/post/index.md --- title: \"index\" date: 2021-03-30T15:56:50+08:00 draft: true --- 我们可以使用typora一类的Markdown编辑器编写好文章后再复制粘贴进去。 编译博客 预览主题效果满意之后就可以编译了： [root@web-blo","date":"2021-05-27","objectID":"/setup-hugo-blog/:0:4","tags":["搭建"],"title":"Hugo+GitHub Action+Github Pages搭建个人博客","uri":"/setup-hugo-blog/"},{"categories":[],"content":"搭建遇到的问题 hugo配置文件参数错误 在本地使用hugo server命令进行本地编译预览时报错: WARN 2020/02/17 20:51:06 found no layout file for \"HTML\" for \"page\": You should create a template file which matches Hugo Layouts Lookup Rules for this combination. 意思为：“找不到用于“页面”的“ HTML”布局文件”。 原因是没有指定所使用的主题。由于hugo new site mysite新建出来的站点目录中，存放主题的目录名为“themes”，导致我以为hugo的站点配置文件config.toml里指定的主题键名为”themes“，而实际应该是“theme”才对，才能正常编译。 [root@web-blog myblog]# vim themes/even/exampleSite/config.toml baseURL = \"http://localhost:1313/\" languageCode = \"en\" defaultContentLanguage = \"en\" # en / zh-cn / ... (This field determines which i18n file to use) title = \"Even - A super concise theme for Hugo\" preserveTaxonomyNames = true enableRobotsTXT = true enableEmoji = true theme = \"even\" 编译成功访问页面没有文章显示 使用hugo new post/index.md新建的文章，是以./archetypes/default.md为模板创建的，默认的draft的值为true，hugo在编译时会忽略所有draft为true的文章，导致编译成功访问站点时发现没有文章显示。 解决办法：文章中draft（草稿）的值需设置为false，或者去掉./archetypes/default.md文件中的draft参数 每次git push之后，刷新站点就显示404 写完文章push到github上之后，再刷新站点会显示404，网页找不到。然后到github pages检查发现之前绑定的域名被清空了。 解决办法：需要在gh-pages.yaml文件中加上cname选项，值为自己的域名。 - name:Deployuses:peaceiris/actions-gh-pages@v3with:github_token:${{ secrets.ACCESS_TOKEN }}publish_dir:./publiccname:domain.com ","date":"2021-05-27","objectID":"/setup-hugo-blog/:0:5","tags":["搭建"],"title":"Hugo+GitHub Action+Github Pages搭建个人博客","uri":"/setup-hugo-blog/"},{"categories":[],"content":"参考链接 Hugo官网：https://gohugo.io/ Hugo中文网：https://www.gohugo.cn/hosting-and-deployment/hosting-on-github/ Hugo中文帮助手册：https://hugo.aiaide.com/ Github Action 官方文档 GitHub Actions 入门教程 ","date":"2021-05-27","objectID":"/setup-hugo-blog/:0:6","tags":["搭建"],"title":"Hugo+GitHub Action+Github Pages搭建个人博客","uri":"/setup-hugo-blog/"},{"categories":[],"content":"Git操作命令总结 git push git push 命用于从将本地的分支版本上传到远程并合并。命令格式如下： git push \u003c远程主机名\u003e \u003c本地分支名\u003e:\u003c远程分支名\u003e 如果本地分支名与远程分支名相同，则可以省略冒号： git push \u003c远程主机名\u003e \u003c本地分支名\u003e git push -f 覆盖远程GitHub仓库的代码，强制推送。主要是为了解决本地仓库内容和远程仓库不一致而导致的push失败报错的问题，（在正常的开发项目中一般不建议这样操作，因为会覆盖所有其他成员提交的代码，只保留你自己的，属于危险操作！）： git push -f origin master #强制推送到origin源 git push -u origin master #正常推送到origin源 git checkout -b main #创建main分支并切换到main分支 git remote -v #查看本地添加的源地址 添加主题：使用git添加子模块的方式添加主题源地址，信息保存在.gitmodule git submodule add https://github.com/halogenica/beautifulhugo.git themes/beautifulhugo ","date":"2021-05-27","objectID":"/setup-hugo-blog/:0:7","tags":["搭建"],"title":"Hugo+GitHub Action+Github Pages搭建个人博客","uri":"/setup-hugo-blog/"},{"categories":[],"content":"2021.07.12更新 因GitHub宣布从 2021 年 8 月 13 日开始，我们将在对 Git 操作进行身份验证时不再接受帐户密码，并将要求使用基于令牌的身份验证。所以本地使用Git操作时，原先使用的账号密码验证身份的方式将被弃用，改成 用户名+token 的方式。 解决方法：点击GitHub头像-\u003eSetting -\u003e Developer settings -\u003e Personal access tokens -\u003e Generate new token，生成一个新的令牌。注意：生成之后需要立马复制下来，因为秘钥只会出现一次。 回到Git，需要清除之前使用的账户名和密码： vim ~/.gitconfig # 或者 cat /etc/git/.gitconfig [credential] # helper = store 注释掉这一行 再使用git push操作，此时会弹出需要验证账户密码，账户填写GitHub账户名，密码填写刚刚生成的token令牌。push成功之后，使用git config --global credential.helper store保存账户和令牌，下次再push就不用再输入账户密码了。 ","date":"2021-05-27","objectID":"/setup-hugo-blog/:0:8","tags":["搭建"],"title":"Hugo+GitHub Action+Github Pages搭建个人博客","uri":"/setup-hugo-blog/"},{"categories":[],"content":"2021.08.12更新：Github Actions自动部署Hugo到Gitee同时刷新Gitee Pages Gitee仓库填入公钥 将id_rsa.pub 填入gitee仓库-\u003e settings→Deploy keys→add personal public key中 Github仓库填入私钥 将id_rsa 填入github仓库-\u003e Settings→Secret→New repository secre 用于之后的程序环境配置访问，命名为GITEE_RSA_PRIVATE_KEY 增加Actions代码 在 .github/workflows/gh-pages.yml文件中新增以下代码： sync: #同步到gitee仓库 needs: deploy runs-on: ubuntu-latest steps: - name: Sync to Gitee uses: wearerequired/git-mirror-action@master env: SSH_PRIVATE_KEY: ${{ secrets.GITEE_RSA_PRIVATE_KEY }} with: # 来源仓库 source-repo: \"git@github.com:JohntunLiu/myblog.git\" # 目标仓库 destination-repo: \"git@gitee.com:JohntunLiu/JohntunLiu.git\" reload-pages: #加载gitee-pages needs: sync runs-on: ubuntu-latest steps: - name: Build Gitee Pages uses: yanglbme/gitee-pages-action@main with: # 注意替换为你的 Gitee 用户名 gitee-username: JohntunLiu # 注意在 Settings-\u003eSecrets 配置 GITEE_PASSWORD gitee-password: ${{ secrets.GITEE_PASSWORD }} # 注意替换为你的 Gitee 仓库，仓库名严格区分大小写，请准确填写，否则会出错 gitee-repo: JohntunLiu/JohntunLiu # 要部署的分支，默认是 master，若是其他分支，则需要指定（指定的分支必须存在） branch: gh-pages commit 提交之后即每次push都会同步代码至gitee仓库上。 ","date":"2021-05-27","objectID":"/setup-hugo-blog/:0:9","tags":["搭建"],"title":"Hugo+GitHub Action+Github Pages搭建个人博客","uri":"/setup-hugo-blog/"}]